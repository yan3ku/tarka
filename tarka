#!/bin/sh
#
# Portable script for backups using rsync, gpg and tar
#
# Commentary:
# Works transparently over SSH by mounting with sshfs
# Unencrypted files are never exposed on the remote system
# Root privileges are required to preserve permissions (see tar man page for -p)
# Due to the critical nature of this script, MAXIMIZE THE LINES OF CODE NOT WRITTEN.
# Install ispell for nice backup identifiers
#
# Requirements:
# GNU tar (-g)
# moreutils
# dateutils
# ispell (/usr/share/dict/words for nice identifiers)
#
# TODO:
# test keep_in (keep command)
# test on directories with spaces?
#
# Code:
#set -x

usage() {
    cat >&2 <<EOF
$0 cmd repo [src] [id] [nr]
cmd:
    full
    list
    check
    delete
    restore
    increment
    keep repo src yearly montly weekly

vars:
    TARKA_NO_WARN      - delete without asking
    TARKA_PASSWORD     - encryption password
    TARKA_RESTORE_DEST - change restore destination
EOF
    exit 1
}

timerbeg() {
    timebeg=$(date +%s)
}

timerend() {
    printf "%ss\n" "$(($(date +%s)-timebeg))"
}

dayfmt() {
    printf %s "%Y-%m-%d"
}

timefmt() {
    printf %s "%H:%M"
}

daytime() {
    date +"$(dayfmt)__$(timefmt)%%%S"
}

mergedir() { # path id | directory for merging tars aka extract dir
    printf %s "${fetchdir}/$(realmangle "$1")~$2"
}

backname() { # destination name for new backup
    printf %s "$(realmangle "$src")~${date}=${id}+${nr}${tag:+--}${tag}"
}

cmpdate() {
    expr "$1" \> "$2" >/dev/null
}

exits() {
    printf "\n%s${1:+; }exiting\n" "--! $1" >&2
    exit 1
}

yesnp() {
    test -n "$TARKA_NO_WARN" && return
    printf %s  "${1:-}${1:+; }continue? (yes/n): "
    read -r choice
    test "$choice" = "yes"
}

passprompt() {
    test -n "$TARKA_PASSWORD" && return
    stty -echo
    printf "repository password: "
    read -r TARKA_PASSWORD
    stty echo
    echo
}

# shellcheck disable=SC2317
cleanup() {
    echo "-- cleaning up"
    rm -f "$repo/.lock"
    rm -f "$repo"/*.snr
    rm -f "$repo"/*.tar
}

# shellcheck disable=SC2317
disconn() {
    arg=$?
    cleanup
    fusermount -u "$repo"
    rmdir "$repo"
    rm -r "$fetchdir"
    exit "$arg"
}

mangle() {  # mangle directory to use as backup filename
    mangle="${1%/}"
    mangle="$(echo "${mangle#/}" | tr '/' '~')"
    printf %s "$mangle"
}

realmangle() {
    mangle "$(realpath "$1")"
}

parse() { # parse backup file name and their metadata eg:
    # home~yaneko~devel~tarka~test-in~2025-10-16__16-22%39=fb63256f+0.tar.gpg
    set -- "$(basename "$1")"
    psrc="$(echo "~${1%~*}~" | tr '~' '/')"
    pmeta="${1##*~}"

    pdate="${pmeta%=*}"
    pid="${pmeta##*=}"
    pid="${pid%+*}"
    pnr="${pmeta#*+}"
    pnr="${pnr%--*}"
    pnr="${pnr%%.*}"
    ptag="${pmeta#*+}"
    ptag="${ptag#*--}"
    ptag="${ptag%%.*}"
    test "$ptag" = "$pnr" && ptag=
    case "$pmeta" in
        *.snr*) ptag="#SNAR#";;
    esac

    pdate="${pdate%\%*}"
    pday="${pdate%__*}"
    ptime="${pdate#*__}"
}

parsedate() { # extension for parse not needed in general case
    pyear="${pday%%-*}"
    pmonth="${pday#*-}"
    pmonth="${pmonth%-*}"
    pweek="$(date -d "$pday" +%U)"
}

latest() { # latest backup for directory
    latest=""
    for i in "$repo"/"$(realmangle "$1")"*.gpg; do
        latest="$i"
    done
    printf %s "$latest"
}

encrypt() {
    timerbeg
    list0 "$1"
    gpg -q --batch --passphrase "$TARKA_PASSWORD" --symmetric --cipher-algo AES256 "$1" ||\
        exits "gpg encrypt error"
    timerend
}

isthere() {
    for i in "$repo"/"$(realmangle "$1")"*"${2:+=$2+}"*.gpg; do
        test -e "$i"
        return "$?"
    done
}

thereis() {
    isthere "$1" "$2" || exits "backup for $1 $2${2:+ }missing"
}

fetch() { # fetches from sshfs
    [ "$repo" = "$fetchdir" ] && return
    echo "-- fetch"
    for i in "$repo"/"$(realmangle "$1")"*"=$2+"*.gpg; do
        test -e "$i" || exits "backup for $1 $2 missing"
        parse "$i"
        test "$ptag" = "#SNAR#" -a "$pnr" -ne "$(($3-1))" && continue
        test "$pnr" -gt "$3" && break
        timerbeg
        list0 "$i"
        sync "$i" "$fetchdir/${i#"$repo"}" || exits "failed fetching $i"
        timerend
    done
}

ungpg() {
    echo "-- ungpg"
    for i in "$fetchdir"/"$(realmangle "$1")"*"=$2+"*.gpg; do
        parse "$i"
        test "$pnr" -gt "$3" && break
        timerbeg
        list0 "$i"
        gpg -q --batch --passphrase "$TARKA_PASSWORD" --output "${i%.gpg}" --decrypt "$i" ||\
            exits "gpg decrypt error"
        timerend
    done
}

untar() {
    echo "-- untar"
    for i in "$fetchdir"/"$(realmangle "$1")"*"=$2+"*.tar; do
        parse "$i"
        test "$pnr" -gt "$3" && break
        timerbeg
        list0 "$i"
        tar -xpf "$i" -C "$fetchdir/" -G || exits "error untaring archive $i"
        rm "$i"
        timerend
    done
    test -e "$(mergedir "$1" "$2")" || exits "assertion failed; merge directory is absent"
}

check() {
    ! test -s "$repo/.cksum" && echo "---- nothing to check" && return
    (cd "$repo" && while IFS=$(printf '\n') read -r i; do
         list0 "${i%: *}"; printf "%s\n" "${i##*: }";
     done<<EOF)
$(sha256sum -c "$repo/.cksum" || exits "verifying checksum failed")
EOF
}

sum() {
    (cd "$repo" && sha256sum "$@">>"$repo/.cksum") || exits "generating checksum failed"
}

remsum() {
    (cd "$repo" && sed "/^[0-9a-z]\{64\}  ${1##*/}$/d" .cksum | sponge .cksum)
}

snarof() {
    snar="${1%.*}"
    snar="${snar%.*}"
    snar="${snar#"$repo/"}.snr"
    printf %s "$snar"
}

# shellcheck disable=SC2317
rem_latest() {
    echo "-- LATEST TO REMOVE:"
    latest="$(latest "$1" "$2")"
    snar="$repo/$(snarof "$latest").gpg"
    list "$latest"
    yesnp || exits
    for i in "$latest" "$snar"; do
        rm "$i"
        remsum "$i"
    done
}

rem() {
    echo "-- TO REMOVE:"
    for i in "$repo"/"$(realmangle "$1")"*"=$2+"*.gpg; do
        test -e "$i" || exits "backup for $1 $2 missing"
        list "$i" -1
    done
    yesnp || exits
    for i in "$repo"/"$(realmangle "$1")"*"=$2+"*.gpg; do
        rm "$i"
        remsum "$i"
    done
}

rand() {
    if test -r /usr/share/dict/words; then # requires ispell
        grep "^[^']\{4,8\}$" /usr/share/dict/words | tr '[:upper:]' '[:lower:]' | shuf -n1
    else
        tr -dc a-z0-9 </dev/urandom | head -c 8
    fi
}

genid() { # each set of incremental backups is grouped by id
    id=
    while test -z "$id"; do
        rand="$(rand)"
        isthere "$src" "$rand" || id="$rand"
    done
    printf %s "$id"
}

listfmt() {
    printf %s "%-40s\t%12s %-5s\t%8s\t%8s %02s\t%-12s"
}

list() {
    parse "$1"
    test -n "$2" && test "$2" -eq -1 && test "$ptag" = "#SNAR#" && return
    test -e "$1" && psize="$(du -k "$1" | cut -f1)" || psize="--"
    # shellcheck disable=SC2059
    printf "$(listfmt)" "$psrc" "$pday" "$ptime" "$psize" "$pid" "$pnr" "$ptag"
    test "${2--1}" -ne 0 && printf "\n"
}

list0() { list "$1" 0; }

lists() {
    # shellcheck disable=SC2059
    test -z "$3" && printf "$(listfmt)\n" "src" "day" "time" "size" "id" "nr" "tag"
    for i in "$repo/${1+$(realmangle "$1")}"*"${2:+=$2+}"*.gpg; do
        test -e "$i" || break
        list "$i" -1
    done
}

sync() {
    rsync "${3--q}" -az --delete  "${1}" "${2}" #--exclude-from="$0-ignore"
}

targ() { # tar with -g
    echo "-- tar"
    bname="$(backname)"
    xdir="$(mergedir "$1" "$2")"
    if test "$isfull" -eq 0; then
        snar="$fetchdir/$(snarof "$latest")"
        list "$snar"
        ! test -e "$snar" && exits "$snar missing; archiving failed"
        cp "$snar" "$fetchdir/$bname.snr"
    else
        list "$bname.snr"
    fi
    list "$bname.tar"
    echo "$bname.tar"
    tar -C "$fetchdir" -cpvf "$fetchdir/$bname.tar" "${xdir#"$fetchdir/"}" \
        -g "$fetchdir/$bname.snr" -P --lzma | ts || exits "archiving $fetchdir/$bname.tar failed"
    ! test -e "$fetchdir/dst.tar" || exits "error archiving $fetchdir/$bname.tar"
    rm -r "$xdir"
}

isrepo() {
    if ! test -e "$repo/.repo"; then
        echo "-- not repository; exiting" >&2
        usage
    fi
}

info() {
    printf "%-10s : %s\n" "repo"  "$repo"
    printf "%-10s : %s\n" "fetch" "$fetchdir"
    test -n "$id"   && printf "%-10s : %s %s\n" "id" "$id" "$nr"
    test -n "$dst"    && printf "%-10s : %s\n" "dest"   "$dst"
    test -n "$bname"  && printf "%-10s : %s\n" "name"   "$bname"
    test -n "$latest" && printf "%-10s : %s\n" "latest" "$latest"
    echo "----------"
}

restore() { # src id
    test -n "$1" || usage
    test -n "$2" || usage
    isnum   "$3" || usage

    src="$(realpath "$1")"
    dst="$(realpath "${TARKA_RESTORE_DEST:-$src}")"
    id="$2"
    nr="$3"
    xdir="$(mergedir "$src" "$id")/"

    thereis "$src" "$id"
    test "$nr" -ge 0 || exits "nr must be positive"
    info # debug info
    yesnp "$dst CONTENT WILL BE DELETED" || exits
    passprompt
    fetch "$src" "$id" "$nr"
    ungpg "$src" "$id" "$nr"
    untar "$src" "$id" "$nr"
    echo "-- restore $src"
    sync "$xdir" "$dst" -v | ts
    rm -r "$xdir"
}

backup() {
    test -n "$1" || usage
    test -e "$1" || exits "source $1 missing"

    src="$(realpath "$1")"
    tag=${2:-}
    date=$(daytime)
    latest=$(latest "$src")

    if test "$isfull" -eq 1 || test ! -e "$latest"; then
        isfull=1
        id="$(genid)"
        nr="0"
    else
        parse "$latest"
        id="$pid"
        nr="$((pnr+1))"
    fi

    mkdir -p "$fetchdir"
    bname="$(backname)"
    xdir="$(mergedir "$src" "$id")" # target for sync and the tar source

    test "$isfull" -eq 0 && thereis "$src" "$id"
    info # debug info
    passprompt
    if test "$isfull" -eq 0; then
        fetch "$src" "$id" "$nr"
        ungpg "$src" "$id" "$nr"
        untar "$src" "$id" "$nr"
    fi
    echo "-- rsync source"
    sync "$src/" "$xdir" -v | ts
    targ "$src" "$id"
    echo "-- gpg"
    encrypt "$fetchdir/$bname".tar
    encrypt "$fetchdir/$bname".snr
    echo "-- rsync repo"
    for i in "$bname.tar.gpg" "$bname.snr.gpg"; do
        timerbeg
        list0 "$fetchdir/$i"
        rsync -z "$fetchdir/$i" "$repo/"
        timerend
    done
    sum "$bname".tar.gpg "$bname".snr.gpg
    touch "$repo/.repo"
}

delete() {
    test -n "$1" || usage
    test -n "$2" || usage

    src="$(realpath "$1")"
    id="$2"

    thereis "$src" "$id"
    info # debug info
    test -z "$3" && rem=rem || rem=rem_latest
    $rem "$src" "$id"
}

isnum() {
    case "$1" in
        [0-9]*) return 0;;
        *)      return 1;;
    esac
}

keep() {
    test -n "$1" || usage
    isnum   "$2" || usage
    isnum   "$3" || usage
    isnum   "$4" || usage

    src="$(realpath "$1")"
    lefty="$2"
    leftm="$3"
    leftw="$4"
    cutoffy="$(dateadd today "-${2}y" -f "$(dayfmt)")"
    cutoffm="$(dateadd today "-${3}m" -f "$(dayfmt)")"
    cutoffw="$(dateadd today "-${4}w" -f "$(dayfmt)")"

    set --; # reverse to start from latest
    for i in "$repo"/"$(realmangle "$src")"*.tar.gpg; do
        set -- "$i" "$@"
    done;

    lasty=
    lastm=
    lastw=
    keep=0
    tokeep="$(mktemp)"
    idall="$(mktemp)"
    for i; do
        parse "$i"
        parsedate
        echo "$pid">>"$idall"
        if cmpdate "$pday" "$cutoffy" && test "$lefty" -gt 0 -a "$lasty" != "$pyear"; then
            lefty=$((lefty-1))
            keep=1
        fi
        if cmpdate "$pday" "$cutoffm" && test "$leftm" -gt 0 -a "$lastm" != "$pmonth"; then
            leftm=$((leftm-1))
            keep=1
        fi
        if cmpdate "$pday" "$cutoffw" && test "$leftw" -gt 0 -a "$lastw" != "$pweek"; then
            leftw=$((leftw-1))
            keep=1
        fi
        test "$keep" -eq 1 && echo "$pid">>"$tokeep"
        keep=0
        lasty="$pyear"
        lastm="$pmonth"
        lastw="$pweek"
    done
    # find the backup groups to delete (this needs testing)
    torem=$(grep -vxFf "$tokeep" "$idall" | sort | uniq)
    while IFS= read -r id; do
        lists "$src" "$id" -1
    done<<EOF
$(sort "$tokeep" | uniq)
EOF
    rm "$tokeep" "$idall"
    test -z "$torem" && echo "---- nothing to remove; exiting" && exit 0
    echo "-- TO REMOVE"
    while IFS= read -r id; do
        lists "$src" "$id" -1
    done<<EOF
$torem
EOF
    yesnp || exits
    while IFS= read -r id; do
        TARKA_NO_WARN=yes rem "$psrc" "$id" >/dev/null
    done<<EOF
$torem
EOF
}

main() {
    test -n "$1" || usage
    test -n "$2" || usage

    isfull=0
    cmd="$1"
    case "$2" in
        *:*)
            fetchdir=$(mktemp -d)
            repo=$(mktemp -d)
            printf %s "-- connecting... "
            (sshfs "$2" "$repo" && printf "ok\n") || exits "error; check auth"
            if test -e "$repo/.lock"; then
               fusermount -u "$repo"
               exits "repository locked"
            fi
            trap disconn EXIT
            ;;
        *)
            test -e "$repo/.lock" && exits "repository locked"
            repo="$(realpath "${2%/}")"
            fetchdir="${repo}"
            trap cleanup EXIT
            ;;
    esac
    shift 2
    touch "$repo/.lock" || exits "couldn't create lock file"
    case "$cmd" in
        f*)   isfull=1; echo "-- full";      backup  "$@"; exit;;
        i*)   isrepo;   echo "-- increment"; backup  "$@"; exit;;
        r*)   isrepo;   echo "-- restoring"; restore "$@"; exit;;
        c*)   isrepo;   echo "-- checking";  check   "$@"; exit;;
        del*) isrepo;   echo "-- deleting";  delete  "$@"; exit;;
        keep) isrepo;   echo "-- keeping";   keep    "$@"; exit;;
        l*)   isrepo;                        lists   "$1"; exit;;
        *) exits "invalid operation: $cmd";;
    esac
}

main "$@"
