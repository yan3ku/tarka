#!/bin/sh
# backup
#
# incremental backups using tar rsync
# works transparently over ssh by mounting with sshfs
# unencrypted files are never visible on the remote
#

parse() {
    set -- "$(basename "$1")"
    psrc="$(echo "~${1%~*}~" | tr '~' '/')"
    pmeta="${1##*~}"

    pdate="${pmeta%=*}"
    phash="${pmeta##*=}"
    phash="${phash%!*}"
    pnr="${pmeta#*!}"
    pnr="${pnr%--*}"
    pnr="${pnr%%.*}"
    ptag="${pmeta#*!}"
    ptag="${ptag#*--}"
    ptag="${ptag%%.*}"
    test "$ptag" = "$pnr" && ptag=""

    # echo "psrc $psrc"
    # echo "date $pdate"
    # echo "hash $phash"
    # echo "pnr $pnr"
    # echo "pnr $ptag"
}

mangle() {
    mangle="${1%/}"
    mangle="$(echo "${mangle#/}" | tr '/' '~')"
    printf "%s" "$mangle"
}

realmangle() {
    mangle "$(realpath "$1")"
}

latest() {
    latest=""
    for i in "$repo"/"$(realmangle $1)"*; do
        if test "${i##*.}" != snar; then
            latest="$i"
        fi
    done
    printf "%s" "$latest"
}

extract_dir() { # path hash
    printf "%s" "${temp}/$(realmangle "$1")~$2"
}

dst() {
    printf "%s" "${1}/$(realmangle $src)~${date}=${hash}!${nr}${tag:+--}${tag}" # target for tar dst
}

encrypt() {
    gpg -q --pinentry-mode=loopback --passphrase "asdf" --symmetric --cipher-algo AES256 "$@"
}

fetch() {
    echo "-- fetch"
    for i in "$repo"/"$(realmangle $1)"*"$2"*.gpg; do
        parse "$i"
        test "$pnr" -gt "${3-2137}" && break
        echo "$i"
        sync "$i" "$temp/${i#$repo}" || exit 1
    done
}

ungpg() {
    echo "-- ungpg"
    for i in "$temp"/"$(realmangle $1)"*"$2"*.gpg; do
        parse "$i"
        test "$pnr" -gt "${3-2137}" && break
        echo "$i..."
        gpg -q --pinentry-mode=loopback --passphrase "asdf" --output "${i%.gpg}.tar" --decrypt "$i"
    done
}

untar() {
    echo "-- untar"
    for i in "$temp"/"$(realmangle $1)"*"$2"*.tar; do
        parse "$i"
        test "$pnr" -gt "${3-2137}" && break
        echo "$i..."
        tar xf "$i" -C "$temp/" -G
    done
    if ! test -e "$(extract_dir "$1" "$2")"; then
        echo "untar error; exiting" >&2
        exit 1
    fi
}

genhash() {
    date +%s | md5sum | head -c 8
}

list() {
    printf "%-40s %-30s %-8s %-4s %s\n" "src" "date" "hash" "nr" "tag"
    for i in "$repo/$(realmangle $1)"*.gpg; do
        test -e "$i" || break
        parse "$i"
        printf "%-40s %-30s %8s %-4s %s\n" "$psrc" "$pdate" "$phash" "$pnr" "$ptag"
    done
}

sync() {
    # exit 0
    rsync "${3--q}" -az --delete  "${1}" "${2}"
    # --exclude-from="$0-ignore" \
}

targ() {
    snar="$repo/${1#$temp/}.snar"
    if test "$isfull" -eq 0 && ! test -e "$snar"; then
        echo "targ; snar at $snar doesn't exist; exiting"
        exit 1
    fi
    echo "-- taring with $snar..."
    tar cf "${2}.tar" "${1}" -g  "$snar" -P --xform="s|^${temp}/||"
    if ! test -e "${2}.tar"; then
        echo "targ error; exiting"
        exit 1
    fi
}

usage() {
    cat >&2 <<EOF
$0 cmd repo args
cmd:
    full
    incremental
    list
    restore
EOF
    exit 1
}

is_repo() {
    test -e "$repo/.repo" || usage
}

info_header() {
    printf "%-15s : %s\n" "temp" "$temp"
    printf "%-15s : %s\n" "tag" "$tag"
    printf "%-15s : %s\n" "extract" "$xdir"
    printf "%-15s : %s\n" "latest" "$latest"
    printf "%-15s : %s\n" "destination" "$dst"
    echo "----------"
}

restore() { # src hash
    src="$(realpath "$1")"
    hash="$2"
    nr="$3"

    if test -e "$src"; then
        read -p "$src will be overwritten; continue? (yes/n): " choice
        test "$choice" != "yes" && exit 0
    fi
    info_header # debug info
    fetch "$src" "$hash" "$nr"
    ungpg "$src" "$hash" "$nr"
    untar "$src" "$hash" "$nr"
    echo "-- restore $src"
    sync "$(extract_dir "$src" "$hash")/" "$src" -v
    rm -r "$(extract_dir "$src" "$hash")"
}


backup() {
    src="$(realpath $1)"
    tag=${2:-}
    date=$(date +'%Y-%m-%d__%H-%M.%S')
    latest=$(latest "$src")

    if test "$isfull" -eq 1 || test ! -e "$latest"; then
        isfull=1
        hash="$(genhash)"
        nr="0"
    else
        parse "$latest"
        hash="$phash"
        nr="$((pnr+1))"
    fi

    xdir=$(extract_dir "$src" "$hash") # target for sync and the tar source
    dst=$(dst "$temp")
    info_header # debug info
    if test "$isfull" -eq 0; then
        fetch "$src" "$hash"
        ungpg "$src" "$hash"
        untar "$src" "$hash"
    fi
    sync "$src/" "$xdir"
    targ "$xdir" "$(dst "$temp")"
    encrypt "$(dst "$temp").tar"
    sync "$(dst "$temp").tar.gpg" "$(dst "$repo").tar.gpg"
    rm -r "$xdir"
    rm -r "$temp"
}

disconn() {
    ARG=$?
    fusermount -u "$sshtemp"
    rmdir "$sshtemp"
    exit $ARG
}

main() {
    test -n "$1" || usage
    test -n "$2" || usage

    isfull=0
    cmd="$1"
    repo="$2"
    temp=$(mktemp -d)
    if echo "$repo" | grep -q ':'; then
        sshtemp=$(mktemp -d)
        ssh="ssh ${repo%:}"
        sshfs "$repo" "$sshtemp"
        trap disconn EXIT
        repo="$sshtemp"
    else
        repo="$(realpath ${2%/})"
    fi
    shift && shift
    case "$cmd" in
        f*)  isfull=1; backup "$@"; exit;;
        i*)  is_repo; backup  "$@"; exit;;
        r*)  is_repo; restore "$@"; exit;;
        l*)  is_repo; list    "$@"; exit;;
        *) echo "invalid operation: $cmd;" >&2
           exit 1;;
    esac
}

main "$@"
