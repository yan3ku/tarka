#!/bin/sh
# backup
#
# this script first unpacks any older incremental backups and then rsynces first
# works transparently over ssh by mounting with sshfs
# all unpacking happens in temp dir outside ssh being secure
# TODO: add gpg encryption
#

parse() {
    set -- "$(basename "$1")"
    psrc="$(echo "~${1%~*}~" | tr '~' '/')"
    pmeta="${1##*~}"

    pdate="${pmeta%=*}"
    phash="${pmeta##*=}"
    phash="${phash%!*}"
    pnr="${pmeta#*!}"
    pnr="${pnr%--*}"
    pnr="${pnr%%.*}"
    ptag="${pmeta#*!}"
    ptag="${ptag#*--}"
    ptag="${ptag%%.*}"
    test "$ptag" = "$pnr" && ptag=""

    # echo "psrc $psrc"
    # echo "date $pdate"
    # echo "hash $phash"
    # echo "pnr $pnr"
    # echo "pnr $ptag"
}

mangle() {
    mangle="${1%/}"
    mangle="$(echo "${mangle#/}" | tr '/' '~')"
    printf "%s" "$mangle"
}

latest() {
    latest=""
    for i in "$repo"/"$(mangle $1)"*; do
        if test "${i##*.}" != snar; then
            latest="$i"
        fi
    done
    printf "%s" "$latest"
}

group() { # path hash
    printf "%s" "${temp}/$(mangle "$1")~$2"
}

untar() {
    echo "-- untar"
    for i in "$repo"/"$(mangle $1)"*"$2"*.tar; do
        parse "$i"
        test "$pnr" -gt "${3-2137}" && break
        echo "$i..."
        tar xf "$i" -C "$temp/" -G
    done
}

genhash() {
    date +%s | md5sum | head -c 8
}

list() {
    printf "%-40s %-30s %-8s %-4s %s\n" "src" "date" "hash" "nr" "tag"
    for i in "$repo/$(mangle $1)"*.tar; do
        test -e "$i" || break
        parse "$i"
        printf "%-40s %-30s %8s %-4s %s\n" "$psrc" "$pdate" "$phash" "$pnr" "$ptag"
    done
}

sync() {
    # exit 0
    echo "-- syncing $2"
    rsync -avz --delete \
          "${1}/" \
          "${2}"
    # --exclude-from="$0-ignore" \
}

targ() {
    snar="$repo/${1#$temp/}.snar"
    if test "$isfull" -eq 0 && ! test -e "$snar"; then
        echo "targ; snar at $snar doesn't exist; exiting"
        exit 1
    fi
    echo "-- taring with $snar..."
    tar cf "${2}.tar" "${1}" -g  "$snar" -P --xform="s|^${temp}/||"
}

usage() {
    echo "$0 cmd repo cmd_args"
    exit 1
}

is_repo() {
    test -e "$repo/.repo" || usage
}

restore() { # src hash
    if test -e "$1"; then
        read -p "$1 will be overwritten; continue? (yes/n): " choice
        test "$choice" != "yes" && exit 0
    fi
    untar "$1" "$2" "$3"
    echo "$(group "$1" "$2")"
    if ! test -e "$(group "$1" "$2")"; then
        echo "untar error; exiting" >&2
        exit 1
    fi
    sync "$(group "$1" "$2")" "$1"
    rm -rf "$(group "$1" "$2")"
}

disconn() {
    ARG=$?
    fusermount -u "$sshtemp"
    rmdir "$sshtemp"
    exit $ARG
}

main() {
    test -n "$1" || usage
    test -n "$2" || usage

    isfull=0
    isinc=0
    isres=0

    cmd="$1"
    repo="$2"
    temp=$(mktemp -d)
    if echo "$repo" | grep -q ':'; then
        sshtemp=$(mktemp -d)
        ssh="ssh ${repo%:}"
        sshfs "$repo" "$sshtemp"
        trap disconn EXIT
        repo="$sshtemp"
    else
        repo="$(realpath ${2%/})"
    fi
    shift && shift
    is_repo
    case "$cmd" in
        f*)  isfull=1 ;;
        i*)  isinc=1  ;;
        r*)  restore  "$@"; exit;;
        l*)  list "$@";     exit;;
        *) echo "invalid operation: $cmd;" >&2
           exit 1;;
    esac

    src="$(realpath $1)"
    tag=${2:-}
    date=$(date +'%Y-%m-%d__%H-%M.%S')
    latest=$(latest "$src")

    if test "$isfull" -eq 1 || test ! -e "$latest"; then
        isfull=1
        hash="$(genhash)"
        nr="0"
    else
        parse "$latest"
        hash="$phash"
        nr="$((pnr+1))"
    fi

    group=$(group "$src" "$hash") # target for sync and the tar source
    dst="${repo}/$(mangle $src)~${date}=${hash}!${nr}${tag:+--}${tag}" # target for tar dst

    printf "%-15s : %s\n" "temp" "$temp"
    printf "%-15s : %s\n" "tag" "$tag"
    printf "%-15s : %s\n" "group" "$group"
    printf "%-15s : %s\n" "latest" "$latest"
    printf "%-15s : %s\n" "destination" "$dst"
    echo "----------"

    test "$isfull" -eq 0 && untar "$src" "$hash"
    sync "$src" "$group"
    targ "$group" "$dst"
    rm -rf "$group"
}

main "$@"
