#!/bin/sh
#
# Portable script to for backups using rsync, gpg and tar
#
# Commentary:
# Works transparently over SSH by mounting with sshfs
# Unencrypted files are never exposed on the remote system
# Root privileges are required to preserve permissions (see tar man page for -p)
# Due to the critical nature of this script, MAXIMIZE THE LINES OF CODE NOT WRITTEN.
#
# Requirements:
# GNU date and tar
#
# TODO:
# list command should list backup size
# test keep_in (keep command)
# test on directories with spaces?
# checksums (with cksum or gpg sign functionality)
#
# Code:
#set -x

usage() {
    cat >&2 <<EOF
$0 cmd repo [src] [hash] [nr]
cmd:
    full
    list
    check
    delete
    restore
    increment
    keep repo src yearly montly weekly

vars:
    NO_WARN      - delete without asking
    PASSWORD     - encryption password
    RESTORE_DEST - change restore destination
EOF
    exit 1
}

dayfmt() {
    printf "%s" "%Y-%m-%d"
}

timefmt() {
    printf "%s" "%H-%M"
}

daytime() {
    date +"$(dayfmt)__$(timefmt).%S"
}

merge_dir() { # path hash | directory for merging tars aka extract dir
    printf "%s" "${fetchdir}/$(realmangle "$1")~$2"
}

dst() { # destination name for new backup
    printf "%s" "$(realmangle "$src")~${date}=${hash}+${nr}${tag:+--}${tag}"
}

cmpdate() {
    expr "$1" \> "$2" >/dev/null
}

exits() {
    printf "%s${1:+; }exiting\n" "--! $1" >&2
    exit 1
}

yesnp() {
    test -n "$NO_WARN" && return
    printf "%s"  "${1:-}${1:+; }continue? (yes/n): "
    read -r choice
    test "$choice" != "yes" && exits
}

passprompt() {
    test -n "$PASSWORD" && return
    stty -echo
    printf "Backup password: "
    read -r PASSWORD
    stty echo
    echo
}

# shellcheck disable=SC2317
cleanup() {
    echo "-- cleaning up"
    rm -f "$repo/.lock"
    rm -f "$repo"/*.snr
    rm -f "$repo"/*.tar
}

# shellcheck disable=SC2317
disconn() {
    arg=$?
    cleanup
    fusermount -u "$repo"
    rmdir "$repo"
    rm -r "$fetchdir"
    exit "$arg"
}

mangle() {  # mangle directory to use as backup filename
    mangle="${1%/}"
    mangle="$(echo "${mangle#/}" | tr '/' '~')"
    printf "%s" "$mangle"
}

realmangle() {
    mangle "$(realpath "$1")"
}

parse() { # parse backup file name and their metadata eg:
    # home~yaneko~devel~tarka~test-in~2025-10-16__16-22.39=fb63256f+0.tar.gpg
    set -- "$(basename "$1")"
    psrc="$(echo "~${1%~*}~" | tr '~' '/')"
    pmeta="${1##*~}"

    pdate="${pmeta%=*}"
    phash="${pmeta##*=}"
    phash="${phash%+*}"
    pnr="${pmeta#*+}"
    pnr="${pnr%--*}"
    pnr="${pnr%%.*}"
    ptag="${pmeta#*+}"
    ptag="${ptag#*--}"
    ptag="${ptag%%.*}"
    case "$pmeta" in
        *.snr*) ptag="#SNAR#";;
    esac

    pdate="${pdate%.*}"
    pday="${pdate%__*}"
    ptime="${pdate#*__}"
}

parsedate() { # extension for parse not needed in general case
    pyear="${pday%%-*}"
    pmonth="${pday#*-}"
    pmonth="${pmonth%-*}"
    pweek="$(date -d "$pday" +%U)"
}

latest() { # latest backup for directory
    latest=""
    for i in "$repo"/"$(realmangle "$1")"*.gpg; do
        latest="$i"
    done
    printf "%s" "$latest"
}

encrypt() {
    gpg -q --batch --passphrase "$PASSWORD" --symmetric --cipher-algo AES256 "$@" || exits "gpg encrypt error"
}

isthere() {
    for i in "$repo"/"$(realmangle "$1")"*"${2:+=$2+}"*.gpg; do
        test -e "$i"
        return "$?"
    done
}

thereis() {
    isthere "$1" "$2" || exits "backup for $1 $2${2:+ }doesn't exist"
}

fetch() { # fetches from sshfs
    [ "$repo" = "$fetchdir" ] && return
    echo "-- fetch"
    for i in "$repo"/"$(realmangle "$1")"*"=$2+"*.gpg; do
        test -e "$i" || exits "backup for $1 $2 doesn't exist"
        parse "$i"
        test "$pnr" -gt "${3:-2137}" && break
        list "$i"
        sync "$i" "$fetchdir/${i#"$repo"}" || exits "failed fetching $i"
    done
}

ungpg() {
    echo "-- ungpg"
    for i in "$fetchdir"/"$(realmangle "$1")"*"=$2+"*.gpg; do
        parse "$i"
        test "$pnr" -gt "${3:-2137}" && break
        list "$i"
        gpg -q --batch --passphrase "$PASSWORD" --output "${i%.gpg}" --decrypt "$i" || exits "gpg decrypt error"
    done
}

untar() {
    echo "-- untar"
    for i in "$fetchdir"/"$(realmangle "$1")"*"=$2+"*.tar; do
        parse "$i"
        test "$pnr" -gt "${3:-2137}" && break
        list "$i"
        tar -xpf "$i" -C "$fetchdir/" -G || exits "error untaring archive $i"
        rm "$i"
    done
    test -e "$(merge_dir "$1" "$2")" || exits "assertion failed; merge directory is absent"
}

# shellcheck disable=SC2317
remhash_latest() {
    echo "-- LATEST TO REMOVE:"
    latest="$(latest "$1" "$2")"
    list "$latest"
    yesnp
    rm "$latest"
}

remhash() {
    echo "-- TO REMOVE:"
    for i in "$repo"/"$(realmangle "$1")"*"=$2+"*.gpg; do
        test -e "$i" || exits "backup for $1 $2 doesn't exist"
        list "$i"
    done
    yesnp
    for i in "$repo"/"$(realmangle "$1")"*"=$2+"*.gpg; do
        rm "$i"
    done
}

rand() {
    tr -dc a-z0-9 </dev/urandom | head -c 8
}

genhash() { # each set of incremental backups is grouped by hash
    hash=
    while test -z "$hash"; do
        rand="$(rand)"
        isthere "$src" "$rand" || hash="$rand"
    done
    printf "%s" "$hash"
}

listfmt() {
    printf "%s" "%-40s\t%12s %-5s\t%8s\t%8s %02s\t%s\n"
}

list() {
    parse "$1"
    test -n "$2" && test "$ptag" = "#SNAR#" && return
    psize="$(du -k "$1" | cut -f1)"
    # shellcheck disable=SC2059
    printf "$(listfmt)" "$psrc" "$pday" "$ptime" "$psize" "$phash" "$pnr" "$ptag"
}

lists() {
    # shellcheck disable=SC2059
    test -z "$3" && printf "$(listfmt)" "src" "day" "time" "size" "hash" "nr" "tag"
    for i in "$repo/${1+$(realmangle "$1")}"*"${2:+=$2+}"*.gpg; do
        test -e "$i" || break
        list "$i" -1
    done
}

sync() {
    rsync "${3--q}" -az --delete  "${1}" "${2}" #--exclude-from="$0-ignore"
}

targ() { # tar with -g
    dst="$fetchdir/$(dst "$1" "$2")"
    xdir="$(merge_dir "$1" "$2")"
    snar="$dst.snar"
    if test "$isfull" -eq 0; then
        snar="$fetchdir/${latest#"$repo"}"
        snar="${snar%.*}"
        snar="${snar%.*}.snr"
        ! test -e "$snar" && exits "snar at $snar doesn't exist"
    fi
    echo "-- tar with $dst.snr..."
    tar -cpf "$dst.tar" "$xdir" -g  "$snar" -P --lzma --xform="s|^${fetchdir}/||" || exits "archiving $1 failed"
    rm "$repo/${snar#"$fetchdir"}.gpg"
    mv "$snar" "$dst.snr"
}

is_repo() {
    if ! test -e "$repo/.repo"; then
        echo "-- not backup repository; exiting" >&2
        usage
    fi
}

info_header() {
    printf "%-10s : %s\n" "repo" "$repo"
    printf "%-10s : %s\n" "fetch" "$fetchdir"
    printf "%-10s : %s\n" "merge" "$xdir"
    printf "%-10s : %s\n" "dest" "$(dst)"
    test -n "$latest" && printf "%-10s : %s\n" "latest" "$latest"
    echo "----------"
}

restore() { # src hash
    test -n "$1" || usage
    test -n "$2" || usage

    src="$(realpath "$1")"
    dst="$(realpath "${RESTORE_DEST:-$src}")"
    hash="$2"
    nr="$3"
    xdir="$(merge_dir "$src" "$hash")/"

    thereis "$src" "$hash"
    info_header # debug info
    yesnp "$dst CONTENT WILL BE DELETED"
    passprompt
    fetch "$src" "$hash" "$nr"
    ungpg "$src" "$hash" "$nr"
    untar "$src" "$hash" "$nr"
    echo "-- restore $src"
    sync "$xdir" "$dst" -v
    rm -r "$xdir"
}

backup() {
    test -n "$1" || usage

    src="$(realpath "$1")"
    tag=${2:-}
    # %S is needed for correct ordering just in case of multiple backups in the same minut
    date=$(daytime)
    latest=$(latest "$src")

    if test "$isfull" -eq 1 || test ! -e "$latest"; then
        isfull=1
        hash="$(genhash)"
        nr="0"
    else
        parse "$latest"
        hash="$phash"
        nr="$((pnr+1))"
    fi

    mkdir -p "$fetchdir"
    xdir="$(merge_dir "$src" "$hash")" # target for sync and the tar source

    test "$isfull" -eq 0 && thereis "$src" "$hash"
    info_header # debug info
    passprompt
    if test "$isfull" -eq 0; then
        fetch "$src" "$hash"
        ungpg "$src" "$hash"
        untar "$src" "$hash"
    fi
    echo "-- sync source"
    sync "$src/" "$xdir"
    targ "$src" "$hash"
    encrypt "$fetchdir/$(dst)".tar
    encrypt "$fetchdir/$(dst)".snr
    echo "-- sync repo"
    for i in "$(dst).tar.gpg" "$(dst).snr.gpg"; do
        rsync -zv "$fetchdir/$i" "$repo/"
    done
    touch "$repo/.repo"
    rm -r "$xdir"
}

delete() {
    test -n "$1" || usage
    test -n "$2" || usage

    src="$(realpath "$1")"
    hash="$2"
    xdir="$(merge_dir "$src" "$hash")/"

    thereis "$src" "$hash"
    info_header # debug info
    test -z "$3" && rem=remhash || rem=remhash_latest
    $rem "$src" "$hash"
}

keep_in() {
    src="$1"
    lefty="$2"
    leftm="$3"
    leftw="$4"
    cutoffy="$(date -d "$2 years  ago"  +"$(dayfmt)")"
    cutoffm="$(date -d "$3 months ago"  +"$(dayfmt)")"
    cutoffw="$(date -d "$4 weeks  ago"  +"$(dayfmt)")"
    set --;
    for i in "$repo"/"$(realmangle "$src")"*.gpg; do
        set -- "$i" "$@"
    done;
    lasty=
    lastm=
    lastw=
    keep=0
    tokeep="$(mktemp)"
    hashall="$(mktemp)"
    for i; do
        parse "$i"
        parsedate
        echo "$phash">>"$hashall"
        if cmpdate "$pday" "$cutoffy" && test "$lefty" -gt 0 && test "$lasty" != "$pyear"; then
            lefty=$((lefty-1))
            keep=1
        fi
        if cmpdate "$pday" "$cutoffm" && test "$leftm" -gt 0 && test "$lastm" != "$pmonth"; then
            leftm=$((leftm-1))
            keep=1
        fi
        if cmpdate "$pday" "$cutoffw" && test "$leftw" -gt 0 && test "$lastw" != "$pweek"; then
            leftw=$((leftw-1))
            keep=1
        fi
        test "$keep" -eq 1 && echo "$phash">>"$tokeep"
        keep=0
        lasty="$pyear"
        lastm="$pmonth"
        lastw="$pweek"
    done
    # find the backup groups to delete (this needs testing)
    torem=$(grep -vxFf "$tokeep" "$hashall")
    while IFS= read -r hash; do
        lists "$src" "$hash" -1
    done<<EOF
$(sort "$tokeep" | uniq)
EOF
    rm "$tokeep" "$hashall"
    test -z "$torem" && echo "-- nothing to remove; exiting" && exit 0
    echo "-- TO REMOVE"
    while IFS= read -r hash; do
        lists "$src" "$hash" -1
    done<<EOF
$torem
EOF
    yesnp
    while IFS= read -r hash; do
        NO_WARN=yes remhash "$psrc" "$hash" >/dev/null
    done<<EOF
$torem
EOF
}

keep() {
    test -n "$1" || usage
    test -n "$2" || usage
    test -n "$3" || usage
    test -n "$4" || usage

    thereis "$1"
    keep_in "$1" "$2" "$3" "$4"
}

main() {
    test -n "$1" || usage
    test -n "$2" || usage

    isfull=0
    cmd="$1"
    case "$2" in
        *:*)
            fetchdir=$(mktemp -d)
            repo=$(mktemp -d)
            sshfs "$2" "$repo" || exits "error connecting with server; check auth"
            trap disconn EXIT
            ;;
        *)
            repo="$(realpath "${2%/}")"
            fetchdir="${repo}"
            trap cleanup EXIT
            ;;
    esac
    shift 2
    test -e "$repo/.lock" && exits "backup repository is locked; either wait for job to finish or delete .lock"
    touch "$repo/.lock" || exits "couldn't create lock file"
    case "$cmd" in
        f*)   isfull=1; echo "-- full";      backup  "$@"; exit;;
        i*)   is_repo;  echo "-- increment"; backup  "$@"; exit;;
        r*)   is_repo;  echo "-- restoring"; restore "$@"; exit;;
        c*)   is_repo;  echo "-- checking";  check   "$@"; exit;;
        del*) is_repo;  echo "-- deleting";  delete  "$@"; exit;;
        keep) is_repo;  echo "-- keeping";   keep    "$@"; exit;;
        l*)   is_repo;                       lists   "$@"; exit;;
        *) exits "invalid operation: $cmd";;
    esac
}

main "$@"
