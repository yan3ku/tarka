#!/bin/sh
#
# Portable script to for backups using rsync, gpg and tar
#
# Commentary:
# Works transparently over SSH by mounting with sshfs
# Unencrypted files are never exposed on the remote system
# Root privileges are required to preserve permissions (see tar man page for -p)
# Due to the critical nature of this script, MAXIMIZE THE LINES OF CODE NOT WRITTEN.
#
# Requirements:
# GNU date and tar
#
# TODO:
# list command should list backup size
# test keep_in (keep command)
# test on directories with spaces?
# encrypt snar
# remove snar
# checksums (with cksum or gpg sign functionality)
#
# Code:
#set -x

usage() {
    cat >&2 <<EOF
$0 cmd repo [src] [hash] [nr]
cmd:
    full
    increment
    restore
    list
    delete
    check
    keep repo src yearly montly weekly

vars:
    NO_WARN      - delete without asking
    RESTORE_DEST - change restore destination
    PASSWORD     - encryption password
EOF
    exit 1
}

dayfmt() {
    printf "%s" "%Y-%m-%d"
}

timefmt() {
    printf "%s" "%H-%M"
}

daytime() {
    date +"$(dayfmt)__$(timefmt).%S"
}

merge_dir() { # path hash | directory for merging tars aka extract dir
    printf "%s" "${fetchdir}/$(realmangle "$1")~$2"
}

dst() { # destination name for new backup
    printf "%s" "$(realmangle "$src")~${date}=${hash}+${nr}${tag:+--}${tag}"
}

cmpdate() {
    expr "$1" \> "$2" >/dev/null
}

exits() {
    printf "%s; exiting\n" "--! $1" >&2
    exit 1
}

yesnp() {
    test -n "$NO_WARN" && return
    printf "%s"  "${1:-}${1:+ }continue? (yes/n): "
    read -r choice
    test "$choice" != "yes" && exit 0
}

passprompt() {
    test -n "$PASSWORD" && return
    stty -echo
    printf "Backup password: "
    read -r PASSWORD
    stty echo
    echo
}

# shellcheck disable=SC2317
cleanup() {
    echo "-- cleaning up"
    rm -f "$repo/.lock"
    rm -f "$repo/*.tar"
}

# shellcheck disable=SC2317
disconn() {
    arg=$?
    cleanup
    fusermount -u "$repo"
    rmdir "$repo"
    rm -r "$fetchdir"
    exit "$arg"
}

mangle() {  # mangle directory to use as backup filename
    mangle="${1%/}"
    mangle="$(echo "${mangle#/}" | tr '/' '~')"
    printf "%s" "$mangle"
}

realmangle() {
    mangle "$(realpath "$1")"
}

parse() { # parse backup file name and their metadata eg:
    # home~yaneko~devel~tarka~test-in~2025-10-16__16-22.39=fb63256f+0.tar.gpg
    set -- "$(basename "$1")"
    psrc="$(echo "~${1%~*}~" | tr '~' '/')"
    pmeta="${1##*~}"

    pdate="${pmeta%=*}"
    phash="${pmeta##*=}"
    phash="${phash%+*}"
    pnr="${pmeta#*+}"
    pnr="${pnr%--*}"
    pnr="${pnr%%.*}"
    ptag="${pmeta#*+}"
    ptag="${ptag#*--}"
    ptag="${ptag%%.*}"
    test "$pmeta" = "${pmeta#*--*}" && ptag=""

    pdate="${pdate%.*}"
    pday="${pdate%__*}"
    ptime="${pdate#*__}"
}

parsedate() { # extension for parse not needed in general case
    pyear="${pday%%-*}"
    pmonth="${pday#*-}"
    pmonth="${pmonth%-*}"
    pweek="$(date -d "$pday" +%U)"
}

latest() { # latest backup for directory
    latest=""
    for i in "$repo"/"$(realmangle "$1")"*.gpg; do
        if test "${i##*.}" != snar; then
            latest="$i"
        fi
    done
    printf "%s" "$latest"
}

encrypt() {
    gpg -q --batch --passphrase "$PASSWORD" --symmetric --cipher-algo AES256 "$@" || exits "gpg encrypt error"
}

isthere() {
    for i in "$repo"/"$(realmangle "$1")"*"${2:+=$2+}"*.gpg; do
        test -e "$i" || exits "backup for $1 $2${2:+ }doesn't exist"
        break
    done
}

fetch() { # fetches from sshfs
    [ "$repo" = "$fetchdir" ] && return
    echo "-- fetch"
    for i in "$repo"/"$(realmangle "$1")"*"=$2+"*.gpg; do
        test -e "$i" || exits "backup for $1 $2 doesn't exist"
        parse "$i"
        test "$pnr" -gt "${3:-2137}" && break
        list "$i"
        sync "$i" "$fetchdir/${i#"$repo"}" || exits "failed fetching $i"
    done
}

ungpg() {
    echo "-- ungpg"
    for i in "$fetchdir"/"$(realmangle "$1")"*"=$2+"*.gpg; do
        parse "$i"
        test "$pnr" -gt "${3:-2137}" && break
        list "$i"
        gpg -q --batch --passphrase "$PASSWORD" --output "${i%.gpg}" --decrypt "$i" || exits "gpg decrypt error"
    done
}

untar() {
    echo "-- untar"
    for i in "$fetchdir"/"$(realmangle "$1")"*"=$2+"*.tar; do
        parse "$i"
        test "$pnr" -gt "${3:-2137}" && break
        list "$i"
        tar -xpf "$i" -C "$fetchdir/" -G || exits "error untaring archive $i"
        rm "$i"
    done
    test -e "$(merge_dir "$1" "$2")" || exits "assertion failed; merge directory is absent"
}

# shellcheck disable=SC2317
remhash_latest() {
    echo "-- LATEST TO REMOVE:"
    latest="$(latest "$1" "$2")"
    list "$latest"
    yesnp
    rm -f "$latest"
}

remhash() {
    echo "-- TO REMOVE:"
    for i in "$repo"/"$(realmangle "$1")"*"=$2+"*.gpg; do
        test -e "$i" || exits "backup for $1 $2 doesn't exist"
        list "$i"
    done
    yesnp
    for i in "$repo"/"$(realmangle "$1")"*"=$2+"*.gpg; do
        rm -f "$i"
    done
}

rand() {
    tr -dc a-z0-9 </dev/urandom | head -c 8
}

genhash() { # each set of incremental backups is grouped by hash
    hash=
    while test -z "$hash"; do
        rand="$(rand)"
        for i in "$repo/$(realmangle "$src")"*"$rand"*.gpg; do
            test -e "$i" || hash="$rand"
            break
        done
    done
    printf "%s" "$hash"
}

listfmt() {
    printf "%s" "%-40s\t%12s %-5s\t%8s %02s\t%s\n"
}

list() {
    parse "$1"
    # shellcheck disable=SC2059
    printf "$(listfmt)" "$psrc" "$pday" "$ptime" "$phash" "$pnr" "$ptag"
}

lists() {
    # shellcheck disable=SC2059
    printf "$(listfmt)"  "src" "day" "time" "hash" "nr" "tag"
    for i in "$repo/${1+$(realmangle "$1")}"*"${2:+=$2+}"*.gpg; do
        test -e "$i" || break
        list "$i"
    done
}

sync() {
    rsync "${3--q}" -az --delete  "${1}" "${2}" #--exclude-from="$0-ignore"
}

targ() { # tar with -g
    snar="$repo/~${1#"$fetchdir"/}.snar"
    test "$isfull" -eq 0 && ! test -e "$snar" && exits "snar at $snar doesn't exist"
    echo "-- tar with $snar..."
    tar -cpf "${2}.tar" "${1}" -g  "$snar" -P --lzma --xform="s|^${fetchdir}/||" || exits "archiving $1 failed"
}

is_repo() {
    if ! test -e "$repo/.repo"; then
        echo "-- not backup repository; exiting" >&2
        usage
    fi
}

info_header() {
    printf "%-10s : %s\n" "repo" "$repo"
    printf "%-10s : %s\n" "fetch" "$fetchdir"
    printf "%-10s : %s\n" "merge" "$xdir"
    printf "%-10s : %s\n" "dest" "$(dst)"
    test -n "$latest" && printf "%-10s : %s\n" "latest" "$latest"
    echo "----------"
}

restore() { # src hash
    test -n "$1" || usage
    test -n "$2" || usage

    src="$(realpath "$1")"
    dst="$(realpath "${RESTORE_DEST:-$src}")"
    hash="$2"
    nr="$3"
    xdir="$(merge_dir "$src" "$hash")/"

    isthere "$src" "$hash"
    info_header # debug info
    yesnp "$dst CONTENT WILL BE DELETED"
    passprompt
    fetch "$src" "$hash" "$nr"
    ungpg "$src" "$hash" "$nr"
    untar "$src" "$hash" "$nr"
    echo "-- restore $src"
    sync "$xdir" "$dst" -v
    rm -r "$xdir"
}

backup() {
    test -n "$1" || usage

    src="$(realpath "$1")"
    tag=${2:-}
    # %S is needed for correct ordering just in case of multiple backups in the same minut
    date=$(daytime)
    latest=$(latest "$src")

    if test "$isfull" -eq 1 || test ! -e "$latest"; then
        isfull=1
        hash="$(genhash)"
        nr="0"
    else
        parse "$latest"
        hash="$phash"
        nr="$((pnr+1))"
    fi

    mkdir -p "$fetchdir"
    xdir=$(merge_dir "$src" "$hash") # target for sync and the tar source

    test "$isfull" -eq 0 && isthere "$src" "$hash"
    info_header # debug info
    passprompt
    if test "$isfull" -eq 0; then
        fetch "$src" "$hash"
        ungpg "$src" "$hash"
        untar "$src" "$hash"
    fi
    echo "-- sync fetch dir"
    sync "$src/" "$xdir"
    targ "$xdir" "$fetchdir/$(dst)"
    encrypt "$fetchdir/$(dst)".tar
    echo "-- sync $repo/$repo.tar.gpg"
    rsync -v "$fetchdir/$(dst).tar.gpg" "$repo/$(dst).tar.gpg"
    touch "$repo/.repo"
    rm -r "$xdir"
    rm "$fetchdir/$(dst).tar"
}

delete() {
    test -n "$1" || usage
    test -n "$2" || usage

    src="$(realpath "$1")"
    hash="$2"
    xdir="$(merge_dir "$src" "$hash")/"

    isthere "$src" "$hash"
    info_header # debug info
    test -z "$3" && rem=remhash || rem=remhash_latest
    $rem "$src" "$hash"
}

keep_in() {
    src="$1"
    lefty="$2"
    leftm="$3"
    leftw="$4"
    cutoffy="$(date -d "$2 years  ago"  +"$(dayfmt)")"
    cutoffm="$(date -d "$3 months ago"  +"$(dayfmt)")"
    cutoffw="$(date -d "$4 weeks  ago"  +"$(dayfmt)")"
    tokeep=
    set --;
    for i in "$repo"/"$(realmangle "$src")"*.gpg; do
        set -- "$(basename "$i")" "$@"
    done;
    lasty=
    lastm=
    lastw=
    keep=0
    for i; do
        # list "$i"
        parse "$i"
        parsedate
        if cmpdate "$pday" "$cutoffy" && test "$lefty" -gt 0 && test "$lasty" != "$pyear"; then
            lefty=$((lefty-1))
            keep=1
        fi
        if cmpdate "$pday" "$cutoffm" && test "$leftm" -gt 0 && test "$lastm" != "$pmonth"; then
            leftm=$((leftm-1))
            keep=1
        fi
        if cmpdate "$pday" "$cutoffw" && test "$leftw" -gt 0 && test "$lastw" != "$pweek"; then
            leftw=$((leftw-1))
            keep=1
        fi
        test "$keep" -eq 1 && tokeep="$i $tokeep"
        keep=0
        lasty="$pyear"
        lastm="$pmonth"
        lastw="$pweek"
    done
    for file in $tokeep; do
        list "$file"
    done
    # find the backup groups to delete (this needs testing)
    norem=1
    lasthash=
    torem=
    for i in "$repo"/"$(realmangle "$src")"*.gpg; do
        parse "$i"
        if test "$lasthash" != "$phash"; then
            test "$norem" -eq 0 && torem="$i $torem"
            norem=0
        fi
        echo "$tokeep" | grep -q "=$phash+" && norem=1
        lasthash="$phash"
    done
    test -z "$torem" && echo "-- nothing to remove; exiting" && exit 0
    echo "-- TO REMOVE"
    for i in $torem; do
        list "$i"
    done
    yesnp
    for file in $torem; do
        parse "$file"
        NO_WARN=yes remhash "$psrc" "$phash"
    done
}

keep() {
    test -n "$1" || usage
    test -n "$2" || usage
    test -n "$3" || usage
    test -n "$4" || usage

    isthere "$1"
    keep_in "$1" "$2" "$3" "$4"
}

main() {
    test -n "$1" || usage
    test -n "$2" || usage

    isfull=0
    cmd="$1"
    case "$2" in
        *:*)
            fetchdir=$(mktemp -d)
            repo=$(mktemp -d)
            sshfs "$2" "$repo" || exits "error connecting with server; check auth"
            trap disconn EXIT
            ;;
        *)
            repo="$(realpath "${2%/}")"
            fetchdir="${repo}"
            trap cleanup EXIT
            ;;
    esac
    shift 2
    test -e "$repo/.lock" && exits "backup repository is locked; either wait for job to finish or delete .lock"
    touch "$repo/.lock" || exits "couldn't create lock file"
    case "$cmd" in
        f*)   isfull=1; echo "-- full";      backup  "$@"; exit;;
        i*)   is_repo;  echo "-- increment"; backup  "$@"; exit;;
        r*)   is_repo;  echo "-- restoring"; restore "$@"; exit;;
        del*) is_repo;  echo "-- deleting";  delete  "$@"; exit;;
        keep) is_repo;  echo "-- keeping";   keep    "$@"; exit;;
        c*)   is_repo;  echo "-- checking";  check   "$@"; exit;;
        l*)   is_repo;                       lists   "$@"; exit;;
        *) exits "invalid operation: $cmd";;
    esac
}

main "$@"
